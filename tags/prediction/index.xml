<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kevin Sookocheff</title>
    <link>http://sookocheff.com/tags/prediction/</link>
    <language>en-us</language>
    <copyright>Copyright Kevin Sookocheff.</copyright>
    <lastBuildDate>Sat, 25 Jul 2015 06:41:06 UTC</lastBuildDate>
    
    <item>
      <title>Modeling Natural Language with N-Gram Models</title>
      <link>http://sookocheff.com/post/nlp/n-gram-modeling/</link>
      <pubDate>Sat, 25 Jul 2015 06:41:06 UTC</pubDate>
      <author>kevin.sookocheff@gmail.com (Kevin Sookocheff)</author>
      <guid>http://sookocheff.com/post/nlp/n-gram-modeling/</guid>
      <description>

&lt;p&gt;One of the most widely used methods natural language is n-gram modeling. This
article explains what an n-gram model is, how it is computed, and what the
probabilities of an n-gram model tell us.&lt;/p&gt;

&lt;h2 id=&#34;what-is-an-n-gram:6aa7a6edb627f8b743e3120c4f84c63a&#34;&gt;What is an n-gram?&lt;/h2&gt;

&lt;p&gt;&lt;blockquote&gt;
  &lt;p&gt;An n-gram is a contiguous sequence of n items from a given sequence of text.&lt;/p&gt;
  &lt;footer&gt;Wikipedia &lt;cite title=&#34;https://en.wikipedia.org/wiki/N-gram&#34;&gt;https://en.wikipedia.org/wiki/N-gram&lt;/cite&gt;&lt;/footer&gt;
&lt;/blockquote&gt;
&lt;/p&gt;

&lt;p&gt;Given a sentence, &lt;code&gt;s&lt;/code&gt;, we can construct a list of n-grams from &lt;code&gt;s&lt;/code&gt; by finding
pairs of words that occur next to each other. For example, given the sentence &amp;ldquo;I
am Sam&amp;rdquo; you can construct bigrams (n-grams of length 2) by finding consecutive
pairs of words.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = &amp;quot;I am Sam.&amp;quot;
&amp;gt;&amp;gt;&amp;gt; tokens = s.split(&amp;quot; &amp;quot;)
&amp;gt;&amp;gt;&amp;gt; bigrams = [(tokens[i],tokens[i+1]) for i in range(0,len(tokens)-1)]
&amp;gt;&amp;gt;&amp;gt; bigrams
[(&#39;I&#39;, &#39;am&#39;), (&#39;am&#39;, &#39;Sam.&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;calculating-n-gram-probability:6aa7a6edb627f8b743e3120c4f84c63a&#34;&gt;Calculating n-gram Probability&lt;/h2&gt;

&lt;p&gt;Given a list of n-grams we can count the number of occurrences of each n-gram;
this count determines the frequency with which an n-gram occurs throughout our
document.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; from collections import Counter
&amp;gt;&amp;gt;&amp;gt; count = Counter(bigrams)
&amp;gt;&amp;gt;&amp;gt; count
[((&#39;am&#39;, &#39;Sam.&#39;), 1), ((&#39;I&#39;, &#39;am&#39;), 1)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this small corpus we only count one occurrence of each n-gram. By dividing
these counts by the size of all n-grams in our list we would get a probability
of 0.5 of each n-gram occurring.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look a larger corpus of words and see what the probabilities can tell us.
The following sequence of bigrams was computed from data downloaded from &lt;a href=&#34;http://www.corpora.heliohost.org/&#34;&gt;HC
Corpora&lt;/a&gt;. It lists the 20 most frequently
encountered bigrams out of 97,810,566 bigrams in the entire corpus.&lt;/p&gt;

&lt;p&gt;This data represents the most frequently used pairs of words in the corpus along
with the number of times they occur.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dns&#34;&gt;of	the	421560
in	the	380608
to	the	207571
for	the	190683
on	the	184430
to	be	153285
at	the	128980
and	the	114232
in	a	109527
with	the	99141
is	a	99053
for	a	90209
from	the	82223
with	a	78918
will	be	78049
of	a	78009
I	was	76788
I	have	76621
going	to	75088
is	the	70045
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By consulting our frequency table of bigrams, we can tell that the sentence
&lt;code&gt;There was heavy rain last night&lt;/code&gt; is much more likely to be grammatically
correct than the sentence &lt;code&gt;There was large rain last night&lt;/code&gt; by the fact that the
bigram &lt;code&gt;heavy rain&lt;/code&gt; occurs much more frequently than &lt;code&gt;large rain&lt;/code&gt; in our corpus.
Said another way, the probability of the bigram &lt;code&gt;heavy rain&lt;/code&gt; is larger than the
probability of the bigram &lt;code&gt;large rain&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;sentences-as-probability-models:6aa7a6edb627f8b743e3120c4f84c63a&#34;&gt;Sentences as probability models&lt;/h2&gt;

&lt;p&gt;More precisely, we can use n-gram models to derive a probability of the sentence
,&lt;code&gt;W&lt;/code&gt;, as the joint probability of each individual word in the sentence, &lt;code&gt;wi&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dns&#34;&gt;P(W) = P(w1, w2, ..., wn)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This can be reduced to a sequence of n-grams using the Chain Rule of
conditional probability.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dns&#34;&gt;P(x1, x2, ..., xn) = P(x1)P(x2|x1)...P(xn|x1,...xn-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a concrete example, let&amp;rsquo;s predict the probability of the sentence &lt;code&gt;There was
heavy rain&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dns&#34;&gt;P(&#39;There was heavy rain&#39;) = P(&#39;There&#39;, &#39;was&#39;, &#39;heavy&#39;, &#39;rain&#39;)
P(&#39;There was heavy rain&#39;) = P(&#39;There&#39;)P(&#39;was&#39;|&#39;There&#39;)P(&#39;heavy&#39;|&#39;There was&#39;)P(&#39;rain&#39;|&#39;There was heavy&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each of the terms on the right hand side of this equation are n-gram
probabilities that we can estimate using the counts of n-grams in our corpus. To
calculate the probability of the entire sentence, we just need to lookup the
probabilities of each component part in the conditional probability.&lt;/p&gt;

&lt;p&gt;Unfortunately, this formula does not scale since we cannot compute n-grams of
every length. For example, consider the case where we have solely bigrams in our
model; we have no way of knowing the probability `P(&amp;lsquo;rain&amp;rsquo;|&amp;lsquo;There was&amp;rsquo;) from
bigrams.&lt;/p&gt;

&lt;p&gt;By using the &lt;a href=&#34;https://en.wikipedia.org/wiki/Markov_property&#34;&gt;Markov Assumption&lt;/a&gt;,
we can simplify our equation by assuming that future states in our model only
depend upon the present state of our model. This assumption means that we can
reduce our conditional probabilities to be approximately equal so that&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dns&#34;&gt;P(&#39;rain&#39;|&#39;There was heavy&#39;) ~ P(&#39;rain&#39;|&#39;heavy&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More generally, we can estimate the probability of a sentence by the
probabilities of each component part. In the equation that follows, the
probability of the sentence is reduced to the probabilities of the sentence&amp;rsquo;s
individual bigrams.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dns&#34;&gt;P(&#39;There was heavy rain&#39;) ~ P(&#39;There&#39;)P(&#39;was&#39;|&#39;There&#39;)P(&#39;heavy&#39;|&#39;was&#39;)P(&#39;rain&#39;|&#39;heavy&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;applications:6aa7a6edb627f8b743e3120c4f84c63a&#34;&gt;Applications&lt;/h2&gt;

&lt;p&gt;What can we use n-gram models for? Given the probabilities of a sentence we can
determine the likelihood of an automated machine translation being correct, we
could predict the next most likely word to occur in a sentence, we could
automatically generate text from speech, automate spelling correction, or
determine the relative sentiment of a piece of text.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using the Google Prediction API to Predict the Sentiment of a Tweet</title>
      <link>http://sookocheff.com/post/prediction-api/predicting-sentiment/</link>
      <pubDate>Mon, 20 Oct 2014 06:23:04 UTC</pubDate>
      <author>kevin.sookocheff@gmail.com (Kevin Sookocheff)</author>
      <guid>http://sookocheff.com/post/prediction-api/predicting-sentiment/</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;https://cloud.google.com/prediction/&#34;&gt;Google Prediction API&lt;/a&gt; offers the
power of Google&amp;rsquo;s machine learning algorithms over a RESTful API interface. The
machine learning algorithms themselves are a complete black box. As a user you
upload the training data and, once it has been analyzed, start classifying new
observations based on the analysis of the training data. I recently spent some
time investigating how to use the API to determine the sentiment of a tweet.
This article collects my thoughts on the experience and a few recommendations
for future work.&lt;/p&gt;

&lt;h2 id=&#34;the-data:f6b93bab65a5a37625cdf99557b98292&#34;&gt;The Data&lt;/h2&gt;

&lt;p&gt;For our experiment we took the text and rating of one million online reviews and
normalized them within a scale of zero to 1000 &amp;ndash; ratings on a scale of one to
four and ratings on a scale of one to ten would be roughly equivalent. We then
segmented the reviews into five broad categories: very negative (0-200),
negative (200-400), neutral (400-600), positive (600-800), very
positive (800-1000). The prediction API requires the data to be in a
specific format; following their guidelines, we stripped the review
text of all punctuation except the apostrophe and lower
cased all characters. What was left was a one million row table with
two columns: the review category and the review content.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;very negative, &amp;quot;the waiter was so mean&amp;quot;
positive, &amp;quot;the bisque is the best in town&amp;quot;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our data was roughly 1 GB. We uploaded this file to Google Cloud Storage
and used the Prediction API to train our model given this dataset.&lt;/p&gt;

&lt;h2 id=&#34;examples:f6b93bab65a5a37625cdf99557b98292&#34;&gt;Examples&lt;/h2&gt;

&lt;p&gt;Once we had a trained model it was time to make predictions. For our application
we took tweets from Twitter mentioning a business and asked the Prediction API
to classify the text of the tweet for sentiment between very negative to very
positive using the normalized review categories of our model. The results were
decidedly mixed as the following examples show. In the first example we attempt
to classify the text &amp;ldquo;this restaurant has the best soup in town&amp;rdquo; and correctly
receive a &amp;ldquo;very positive&amp;rdquo; result.&lt;/p&gt;

&lt;p&gt;&lt;a class=&#34;thumbnail&#34; href=&#34;http://sookocheff.com/img/2014-10-20-prediction-api/bestsoup.png&#34;&gt;
  &lt;img src=&#34;http://sookocheff.com/img/2014-10-20-prediction-api/bestsoup.png&#34; alt=&#34;The Best Soup in Town&#34;&gt;
&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;As a counter example, the text &amp;ldquo;this restaurant has the worst soup in town&amp;rdquo; also
recieves a &amp;ldquo;very positive&amp;rdquo; result, although with less confidence and with &amp;ldquo;very
negative&amp;rdquo; being the most likely second choice.&lt;/p&gt;

&lt;p&gt;&lt;a class=&#34;thumbnail&#34; href=&#34;http://sookocheff.com/img/2014-10-20-prediction-api/worstsoup.png&#34;&gt;
  &lt;img src=&#34;http://sookocheff.com/img/2014-10-20-prediction-api/worstsoup.png&#34; alt=&#34;The Worst Soup in Town&#34;&gt;
&lt;/a&gt;
&lt;/p&gt;

&lt;h2 id=&#34;conclusions:f6b93bab65a5a37625cdf99557b98292&#34;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Most of the tweets were categorized as very positive, regardless of content. In
addition, most of the tweets had almost equal likelihood of being in the very
negative or very positive category with very positive being more likely most of
the time.&lt;/p&gt;

&lt;p&gt;Why is this?&lt;/p&gt;

&lt;p&gt;Most Internet reviews are either very positive or very negative so most of the
content from the tweet will fall into one of these categories in our model. I
believe that by adjusting our training data to have equal amounts of reviews for
each category we would get better results.&lt;/p&gt;

&lt;p&gt;My recommendation is that if you intend to use the Prediction API for a serious
business task that you also have a strong enough background in machine learning
to tweak your model &lt;em&gt;before&lt;/em&gt; using the Prediction API to analyze and host it. In
short, use the Prediction API as cloud-based access to your existing model that
you already know works. Don&amp;rsquo;t use the Prediction API to help you build a working
model. The black box nature of the Prediction API makes it difficult to diagnose
and correct any data problems you may have.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
