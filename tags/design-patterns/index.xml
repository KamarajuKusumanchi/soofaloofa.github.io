<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kevin Sookocheff</title>
    <link>http://sookocheff.com/tags/design-patterns/</link>
    <language>en-us</language>
    <copyright>Copyright Kevin Sookocheff.</copyright>
    <lastBuildDate>Thu, 09 Jul 2015 19:40:15 UTC</lastBuildDate>
    
    <item>
      <title>Structuring an Application using Model View Controller</title>
      <link>http://sookocheff.com/post/architecture/structuring-with-mvc/</link>
      <pubDate>Thu, 09 Jul 2015 19:40:15 UTC</pubDate>
      <author>kevin.sookocheff@gmail.com (Kevin Sookocheff)</author>
      <guid>http://sookocheff.com/post/architecture/structuring-with-mvc/</guid>
      <description>

&lt;p&gt;Early pioneers in object-oriented programming paved the path towards using Model
View Controller (MVC) for graphical user interfaces as early as 1970 and web
applications have continued using the pattern to separate business logic from
display. This article attempts to clarify the use of Model View Controller
within web applications â€” giving consideration to the fact that most developers
will be building their application using an existing web framework.&lt;/p&gt;

&lt;h2 id=&#34;model-view-controller:9f1e744e0ce624b070c416549ce80507&#34;&gt;Model View Controller&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start our investigation of Model View Controller for web applications by examining a broad
overview of how the Model, View and Controller work together to handle a single
request to a web server. This diagram is adapted from the book &lt;a href=&#34;http://martinfowler.com/books/eaa.html&#34;&gt;Patterns of
Enterprise Application Architecture by Martin
Fowler&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a class=&#34;thumbnail&#34; href=&#34;http://sookocheff.com/img/architecture/structuring-with-mvc/MVCBroadOverview.png&#34;&gt;
  &lt;img src=&#34;http://sookocheff.com/img/architecture/structuring-with-mvc/MVCBroadOverview.png&#34; alt=&#34;Model View Controller&#34;&gt;
&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;A request comes in to the application and is handled by an input controller (1).
The controller parses any data that is on the request (e.g., query parameters,
cookies, form data) and chooses the appropriate model objects and
performs domain logic for this request (2). The controller chooses a view for
displaying the result of the domain logic and data or model objects are passed
into the view (3). The view uses this data to render the response (4). Finally,
the response is returned to the user via the controller (5).&lt;/p&gt;

&lt;p&gt;The most important reason for applying Model View Controller is to ensure that
models are completely separated from the presentation. This makes it easier to
modify the presentation independently of domain and business logic. Within this
request flow the model objects are responsible for integrating with the
persistent data source and potentially gathering information for display in the
view.&lt;/p&gt;

&lt;h2 id=&#34;web-frameworks:9f1e744e0ce624b070c416549ce80507&#34;&gt;Web Frameworks&lt;/h2&gt;

&lt;p&gt;Most web frameworks incorporate most of the functionality described by Model
View Controller in their design. The Model View Controller and associated
patterns were developed when web frameworks where in their infancy and largely
outline the correct process to create a web framework from scratch. A common
misconception for new web application developers learning Model View Controller
is to implement MVC within their web framework. This unfortunately leads to a
convoluted design with unnecessary layers of indirection during the processing
of the web request.&lt;/p&gt;

&lt;p&gt;My advice for new developers is to lean on your framework to implement Model
View Controller and focus your attention on your business logic. As a concrete
example, I will walk through a sample architecture for App Engine applications
that uses &lt;a href=&#34;https://webapp-improved.appspot.com/&#34;&gt;webapp2&lt;/a&gt;,
&lt;a href=&#34;https://cloud.google.com/appengine/docs/python/ndb/&#34;&gt;ndb&lt;/a&gt;, and
&lt;a href=&#34;http://jinja.pocoo.org/docs/dev/&#34;&gt;jinja&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this example file, App Engine acts as our web server implementing the
&lt;a href=&#34;http://wsgi.readthedocs.org/en/latest/&#34;&gt;WSGI&lt;/a&gt; specification. Once a request is
received by the server it is forwarded to the webapp2 framework which handles
routing to a &lt;a href=&#34;http://martinfowler.com/eaaCatalog/pageController.html&#34;&gt;Page Controller&lt;/a&gt;.  So far,
the WSGI application and webapp2 handle the creation of a controller to handle
the request.&lt;/p&gt;

&lt;h2 id=&#34;model-view-controller-for-app-engine:9f1e744e0ce624b070c416549ce80507&#34;&gt;Model View Controller for App Engine&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import webapp2


class HelloWorld(webapp2.RequestHandler):

    def get(self):
        self.response.out.write(&#39;Hello World&#39;)


ROUTES = [
    webapp2.Route(&#39;/&#39;, handler=HelloWorld)
]

APPLICATION = webapp2.WSGIApplication(ROUTES)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can start by implementing handling the request and customizing our response
based on any incoming request data (1).&lt;/p&gt;

&lt;p&gt;&lt;a class=&#34;thumbnail&#34; href=&#34;http://sookocheff.com/img/architecture/structuring-with-mvc/InstantiateController.png&#34;&gt;
  &lt;img src=&#34;http://sookocheff.com/img/architecture/structuring-with-mvc/InstantiateController.png&#34; alt=&#34;Instantiating a Controller&#34;&gt;
&lt;/a&gt;
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import webapp2


class HelloWorld(webapp2.RequestHandler):

    def get(self):
        name = self.request.params.get(&#39;name&#39;)
        if name:
            self.response.out.write(&#39;Hello %s&#39; % name)
        else:
            self.response.out.write(&#39;Hello World&#39;)


ROUTES = [
    webapp2.Route(&#39;/&#39;, handler=HelloWorld)
]

APPLICATION = webapp2.WSGIApplication(ROUTES)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s connect our application to a model (2).&lt;/p&gt;

&lt;p&gt;&lt;a class=&#34;thumbnail&#34; href=&#34;http://sookocheff.com/img/architecture/structuring-with-mvc/PerformDomainLogic.png&#34;&gt;
  &lt;img src=&#34;http://sookocheff.com/img/architecture/structuring-with-mvc/PerformDomainLogic.png&#34; alt=&#34;Perform Domain Logic&#34;&gt;
&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;The model in our diagram is connected to a data source and is responsible for
converting from the data source to an in memory representation. ndb follows an
&lt;a href=&#34;http://www.martinfowler.com/eaaCatalog/activeRecord.html&#34;&gt;Active Record&lt;/a&gt;
pattern, providing a one-to-one mapping from the data source to memory, and a
&lt;a href=&#34;http://www.martinfowler.com/eaaCatalog/tableModule.html&#34;&gt;Table Module&lt;/a&gt; for . You
could build up a rich &lt;a href=&#34;http://www.martinfowler.com/eaaCatalog/domainModel.html&#34;&gt;Domain
Model&lt;/a&gt; based on ndb. In
my opinion the overhead of a Domain Model outweighs its benefits and you end up
fighting against a pattern that is already available with ndb. For our simple
application, our model is a user object that is created or loaded based on the
query parameter passed in on the request.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import webapp2
from google.appengine.ext import ndb


class User(ndb.Model):

    name = ndb.StringProperty()


class HelloWorld(webapp2.RequestHandler):

    def get(self):
        name = self.request.params.get(&#39;name&#39;)
        if name:
            user = ndb.Key(&#39;User&#39;, name).get()
            if not user:
                user = User(name=name, id=name)
                user.put()
            self.response.out.write(&#39;Hello %s&#39; % user.name)
        else:
            self.response.out.write(&#39;Hello World&#39;)


ROUTES = [
    webapp2.Route(&#39;/&#39;, handler=HelloWorld)
]

APPLICATION = webapp2.WSGIApplication(ROUTES)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve leveraged ndb to handle mapping from our data source to an in memory
representation and don&amp;rsquo;t need to define any special handling to interact with
the data source. This is typical when working with a pre-existing framework and
I would suggest caution when making any more complex data source transformations
&lt;em&gt;unless you are building your own framework&lt;/em&gt;. We also perform some simple domain
logic in our controller. Since getting or creating a model is a common operation
we may want to push this function to the model itself to provide reuse. The
Active Record pattern that ndb implements lends itself to this structure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import webapp2
from google.appengine.ext import ndb


class User(ndb.Model):

    name = ndb.StringProperty()

    @classmethod
    def get_or_create(cls, name):
        if not name:
            return None

        user = ndb.Key(&#39;User&#39;, name).get()
        if not user:
            user = User(name=name, id=name)
            user.put()
        return user


class HelloWorld(webapp2.RequestHandler):

    def get(self):
        name = self.request.params.get(&#39;name&#39;)
        user = User.get_or_create(name)

        if user:
            self.response.out.write(&#39;Hello %s&#39; % user.name)
        else:
            self.response.out.write(&#39;Hello World&#39;)


ROUTES = [
    webapp2.Route(&#39;/&#39;, handler=HelloWorld)
]

APPLICATION = webapp2.WSGIApplication(ROUTES)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;ve separated common functionality to the model and used the controller to
coordinate the domain logic. As this application grows the controller can be
leveraged to perform more complex domain logic on multiple models. If we find
that we have two controllers performing similar logic we may want to move that
particular functionality out into a shared script.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s extend our example by rendering our page using a view.&lt;/p&gt;

&lt;p&gt;&lt;a class=&#34;thumbnail&#34; href=&#34;http://sookocheff.com/img/architecture/structuring-with-mvc/RenderView.png&#34;&gt;
  &lt;img src=&#34;http://sookocheff.com/img/architecture/structuring-with-mvc/RenderView.png&#34; alt=&#34;Rendering the View&#34;&gt;
&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;We leverage Jinja to act as our view and provide the
interpretation and rendering of our model following a
&lt;a href=&#34;http://www.martinfowler.com/eaaCatalog/templateView.html&#34;&gt;Template View&lt;/a&gt;
pattern. We&amp;rsquo;ve again kept our interpretation of Model View Controller simple by
working within our web application framework rather than against it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
import webapp2
import jinja2
from google.appengine.ext import ndb


JINJA_ENVIRONMENT = jinja2.Environment(
    loader=jinja2.FileSystemLoader(os.path.dirname(__file__)),
    extensions=[&#39;jinja2.ext.autoescape&#39;])


class User(ndb.Model):

    name = ndb.StringProperty()

    @classmethod
    def get_or_create(cls, name):
        if not name:
            return None

        user = ndb.Key(&#39;User&#39;, name).get()
        if not user:
            user = User(name=name, id=name)
            user.put()
        return user


class HelloWorld(webapp2.RequestHandler):

    def get(self):
        name = self.request.params.get(&#39;name&#39;)
        user = User.get_or_create(name)

        name = user.name if user else &#39;World&#39;

        template = JINJA_ENVIRONMENT.get_template(&#39;index.html&#39;)
        self.response.out.write(template.render(name=name))


ROUTES = [
    webapp2.Route(&#39;/&#39;, handler=HelloWorld)
]

APPLICATION = webapp2.WSGIApplication(ROUTES)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, webapp2 and the WSGI application and server handle returning our
response to the user and completing the request-response cycle.&lt;/p&gt;

&lt;p&gt;&lt;a class=&#34;thumbnail&#34; href=&#34;http://sookocheff.com/img/architecture/structuring-with-mvc/ReturnResponse.png&#34;&gt;
  &lt;img src=&#34;http://sookocheff.com/img/architecture/structuring-with-mvc/ReturnResponse.png&#34; alt=&#34;Returning a Response&#34;&gt;
&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;As our application becomes more complex, we may want to separate our code into
separate modules for Model, View and Controller. I recommend including an
additional module called Scripts that stores more complex interactions between
models that are used in multiple controllers. However, since each request to our
application is typically an independent transaction sharing logic between
different requests should be rare. The final directory structure should look
something like the following.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;.
â”œâ”€â”€ app.yaml
â”œâ”€â”€ controller
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â””â”€â”€ index.py
â”œâ”€â”€ main.py
â”œâ”€â”€ model
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â””â”€â”€ user.py
â”œâ”€â”€ scripts
â”‚Â Â  â””â”€â”€ __init__.py
â””â”€â”€ view
    â”œâ”€â”€ __init__.py
    â””â”€â”€ index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The overarching theme of this article is to leverage our existing framework and
libraries to implement the Model View Controller pattern for us. Leave your
application simple and lean on your tools. Of course, design patterns are
subjective and my opinion may not apply to your use case â€” take what works for
you and leave the rest.&lt;/p&gt;

&lt;p&gt;Full source code for this example is available on &lt;a href=&#34;https://github.com/soofaloofa/ModelViewController&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
