<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kevin Sookocheff</title>
    <link>http://sookocheff.com/tags/bash/</link>
    <language>en-us</language>
    <copyright>Copyright Kevin Sookocheff.</copyright>
    <lastBuildDate>Sun, 01 Feb 2015 14:53:37 CST</lastBuildDate>
    
    <item>
      <title>A pypiserver Deployment Script</title>
      <link>http://sookocheff.com/post/python/a-pypiserver-deployment-script/</link>
      <pubDate>Sun, 01 Feb 2015 14:53:37 CST</pubDate>
      <author>kevin.sookocheff@gmail.com (Kevin Sookocheff)</author>
      <guid>http://sookocheff.com/post/python/a-pypiserver-deployment-script/</guid>
      <description>&lt;p&gt;At Vendasta we&amp;rsquo;ve been slowly adopting pypi and pip for our internal code
libraries and the time has come to deploy our own private pypi server. After
evaluating a few options I settled on the simplistic
&lt;a href=&#34;https://pypi.python.org/pypi/pypiserver&#34;&gt;pypiserver&lt;/a&gt; &amp;ndash; a barebones
implementation of the &lt;a href=&#34;https://pypi.python.org/simple/&#34;&gt;simple HTTP API&lt;/a&gt; to
pypi.&lt;/p&gt;

&lt;p&gt;The deployment uses nginx as a front-end to pypiserver. pypiserver itself is ran
and monitored using supervisord. I created a bash script that creates a user and
group to run pypiserver and installs and runs nginx, supervisord and pypiserver.
I&amp;rsquo;ve been running this bash script through Vagrant to deploy a custom pypiserver
for private use. I wanted to save this code for posterity and hopefully help
someone else working on the same task.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/usr/bin/env bash

STARTUP_VERSION=1
STARTUP_MARK=/var/startup.script.$STARTUP_VERSION

# Exit if this script has already ran
if [[ -f $STARTUP_MARK ]]; then
  exit 0  
fi

set -o nounset
set -o pipefail
set -o errexit

# Install prerequesites
sudo apt-get update
sudo apt-get install -y vim
sudo apt-get install -y apache2-utils
sudo apt-get install -y nginx
sudo apt-get install -y supervisor

# Install pip
wget &amp;quot;https://bootstrap.pypa.io/get-pip.py&amp;quot;
sudo python get-pip.py

# Install pypiserver with passlib for upload support
sudo pip install passlib
sudo pip install pypiserver

# Set the port configuration
proxy_port=8080
pypi_port=7201

# Create a user and group to run pypiserver
user=pypiusername
password=pypipasswrd
group=$user

sudo groupadd &amp;quot;$group&amp;quot;
sudo useradd $user -m -g $group -G $group
sudo -u $user -H -s eval &#39;htpasswd -scb $HOME/.htaccess&#39; &amp;quot;$user $password&amp;quot;
sudo -u $user -H -s eval &#39;mkdir -p $HOME/packages&#39;

##############
# nginx config
##############
echo &amp;quot;$user:$(openssl passwd -crypt $password)&amp;quot; &amp;gt; /etc/nginx/user.pwd

# nginx can&#39;t run as a daemon to work with supervisord
echo &amp;quot;daemon off;&amp;quot; &amp;gt;&amp;gt; /etc/nginx/nginx.conf

cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/nginx/sites-enabled/pypi-server.conf
server {
  listen $proxy_port;
  location / {
    proxy_pass http://localhost:$pypi_port;
    auth_basic &amp;quot;PyPi Authentication&amp;quot;;
    auth_basic_user_file /etc/nginx/user.pwd;
  }
}
EOF

rm /etc/nginx/sites-enabled/default

###################
# supervisor config
###################
cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/supervisor/conf.d/pypi-server.conf
[program:pypi-server]
command=pypi-server -p $pypi_port -P /home/$user/.htaccess /home/$user/packages
directory=/home/$user
user=$user
autostart=true
autorestart=true
stderr_logfile=/var/log/pypi-server.err.log
stdout_logfile=/var/log/pypi-server.out.log
EOF

cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/supervisor/conf.d/nginx.conf
[program:nginx]
command=/usr/sbin/nginx
autostart=true
autorestart=true
stdout_events_enabled=true
stderr_events_enabled=true
EOF

sudo supervisorctl reread
sudo supervisorctl update

touch $STARTUP_MARK
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Parsing bash script options with getopts</title>
      <link>http://sookocheff.com/post/bash/parsing-bash-script-arguments-with-shopts/</link>
      <pubDate>Sun, 04 Jan 2015 12:31:51 UTC</pubDate>
      <author>kevin.sookocheff@gmail.com (Kevin Sookocheff)</author>
      <guid>http://sookocheff.com/post/bash/parsing-bash-script-arguments-with-shopts/</guid>
      <description>

&lt;p&gt;A common task in shell scripting is to parse command line arguments to your
script. Bash provides the &lt;code&gt;getopts&lt;/code&gt; built-in function to do just that. This
tutorial explains how to use the &lt;code&gt;getopts&lt;/code&gt; built-in function to parse arguments and options to a bash script.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;getopts&lt;/code&gt; function takes three parameters. The first is a specification of
which options are valid, listed as a sequence of letters. For example, the
string &lt;code&gt;&#39;ht&#39;&lt;/code&gt; signifies that the options &lt;code&gt;-h&lt;/code&gt; and &lt;code&gt;-t&lt;/code&gt; are valid.&lt;/p&gt;

&lt;p&gt;The second argument to &lt;code&gt;getopts&lt;/code&gt; is a variable that will be populated with the
option or argument to be processed next. In the following loop, &lt;code&gt;opt&lt;/code&gt; will hold
the value of the current option that has been parsed by &lt;code&gt;getopts&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;while getopts &amp;quot;:ht&amp;quot; opt; do
  case ${opt} in
    h ) # process option a
      ;;
    t ) # process option l
      ;;
    \? ) echo &amp;quot;Usage: cmd [-h] [-t]
      ;;
  esac
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example shows a few additional features of &lt;code&gt;getopts&lt;/code&gt;. First, if an invalid
option is provided, the option variable is assigned the value &lt;code&gt;?&lt;/code&gt;. You can catch
this case and provide an appropriate usage message to the user. Second, this
behaviour is only true when you prepend the list of valid options with &lt;code&gt;:&lt;/code&gt; to
disable the default error handling of invalid options. It is recommended to
always disable the default error handling in your scripts.&lt;/p&gt;

&lt;p&gt;The third argument to &lt;code&gt;getopts&lt;/code&gt; is the list of arguments and options to be
processed. When not provided, this defaults to the arguments and options
provided to the application (&lt;code&gt;$@&lt;/code&gt;). You can provide this third argument to use
&lt;code&gt;getopts&lt;/code&gt; to parse any list of arguments and options you provide.&lt;/p&gt;

&lt;h2 id=&#34;shifting-processed-options:f692909f0238f3b8bcae53295fc7adf1&#34;&gt;Shifting processed options&lt;/h2&gt;

&lt;p&gt;The variable &lt;code&gt;OPTIND&lt;/code&gt; holds the number of options parsed by the last call to
&lt;code&gt;getopts&lt;/code&gt;. It is common practice to call the &lt;code&gt;shift&lt;/code&gt; command at the end of your
processing loop to remove options that have already been handled from &lt;code&gt;$@&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;shift $((OPTIND -1))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parsing-options-with-arguments:f692909f0238f3b8bcae53295fc7adf1&#34;&gt;Parsing options with arguments&lt;/h2&gt;

&lt;p&gt;Options that themselves have arguments are signified with a &lt;code&gt;:&lt;/code&gt;. The argument to
an option is placed in the variable &lt;code&gt;OPTARG&lt;/code&gt;. In the following example, the
option &lt;code&gt;t&lt;/code&gt; takes an argument. When the argument is provided, we copy its value
to the variable &lt;code&gt;target&lt;/code&gt;. If no argument is provided &lt;code&gt;getopts&lt;/code&gt; will set &lt;code&gt;opt&lt;/code&gt; to
&lt;code&gt;:&lt;/code&gt;. We can recognize this error condition by catching the &lt;code&gt;:&lt;/code&gt; case and printing
an appropriate error message.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;while getopts &amp;quot;:t:&amp;quot; opt; do
  case ${opt} in 
    t )
      target=$OPTARG
      ;;
    \? )
      echo &amp;quot;Invalid option: $OPTARG&amp;quot; 1&amp;gt;&amp;amp;2
      ;;
    : )
      echo &amp;quot;Invalid option: $OPTARG requires an argument&amp;quot; 1&amp;gt;&amp;amp;2
      ;;
  esac
done
shift $((OPTIND -1))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;an-extended-example-parsing-nested-arguments-and-options:f692909f0238f3b8bcae53295fc7adf1&#34;&gt;An extended example &amp;ndash; parsing nested arguments and options&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s walk through an extended example of processing a command that takes
options, has a sub-command, and whose sub-command takes an additional option
that has an argument. This is a mouthful so let&amp;rsquo;s break it down using an
example. Let&amp;rsquo;s say we are writing our own version of the &lt;a href=&#34;https://pip.pypa.io/en/latest/&#34;&gt;&lt;code&gt;pip&lt;/code&gt;
command&lt;/a&gt;. In this version you can call &lt;code&gt;pip&lt;/code&gt;
with the &lt;code&gt;-h&lt;/code&gt; option to display a help message.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; pip -h
Usage: 
    pip -h                      Display this help message.
    pip install                 Install a Python package.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use &lt;code&gt;getopts&lt;/code&gt; to parse the &lt;code&gt;-h&lt;/code&gt; option with the following &lt;code&gt;while&lt;/code&gt; loop.
In it we catch invalid options with &lt;code&gt;\?&lt;/code&gt; and &lt;code&gt;shift&lt;/code&gt; all arguments that have
been processed with &lt;code&gt;shift $((OPTIND -1))&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;while getopts &amp;quot;:h&amp;quot; opt; do
  case ${opt} in
    h )
      echo &amp;quot;Usage:&amp;quot;
      echo &amp;quot;    pip -h                      Display this help message.&amp;quot;
      echo &amp;quot;    pip install                 Install a Python package.&amp;quot;
      exit 0
      ;;
    \? )
      echo &amp;quot;Invalid Option: -$OPTARG&amp;quot; 1&amp;gt;&amp;amp;2
      exit 1
      ;;
  esac
done
shift $((OPTIND -1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s add the sub-command &lt;code&gt;install&lt;/code&gt; to our script.  &lt;code&gt;install&lt;/code&gt; takes as an
argument the Python package to install.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; pip install urllib3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;install&lt;/code&gt; also takes an option, &lt;code&gt;-t&lt;/code&gt;. &lt;code&gt;-t&lt;/code&gt; takes as an argument the location to
install the package to relative to the current directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; pip install urllib3 -t ./src/lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To process this line we must find the sub-command to execute. This value is the
first argument to our script.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;subcommand=$1
shift # Remove `pip` from the argument list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can process the sub-command &lt;code&gt;install&lt;/code&gt;. In our example, the option &lt;code&gt;-t&lt;/code&gt; is
actually an option that follows the package argument so we begin by removing
&lt;code&gt;install&lt;/code&gt; from the argument list and processing the remainder of the line.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;case &amp;quot;$subcommand&amp;quot; in
  install)
    package=$1
    shift # Remove `install` from the argument list
    ;;
esac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After shifting the argument list we can process the remaining arguments as if
they are of the form &lt;code&gt;package -t src/lib&lt;/code&gt;. The &lt;code&gt;-t&lt;/code&gt; option takes an argument
itself. This argument will be stored in the variable &lt;code&gt;OPTARG&lt;/code&gt; and we save it to
the variable &lt;code&gt;target&lt;/code&gt; for further work.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;case &amp;quot;$subcommand&amp;quot; in
  install)
    package=$1
    shift # Remove `install` from the argument list

  while getopts &amp;quot;:t:&amp;quot; opt; do
    case ${opt} in
      t )
        target=$OPTARG
        ;;
      \? )
        echo &amp;quot;Invalid Option: -$OPTARG&amp;quot; 1&amp;gt;&amp;amp;2
        exit 1
        ;;
      : )
        echo &amp;quot;Invalid Option: -$OPTARG requires an argument&amp;quot; 1&amp;gt;&amp;amp;2
        exit 1
        ;;
    esac
  done
  shift $((OPTIND -1))
  ;;
esac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Putting this all together, we end up with the following script that parses
arguments to our version of &lt;code&gt;pip&lt;/code&gt; and its sub-command &lt;code&gt;install&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;package=&amp;quot;&amp;quot;  # Default to empty package
target=&amp;quot;&amp;quot;  # Default to empty target

# Parse options to the `pip` command
while getopts &amp;quot;:h&amp;quot; opt; do
  case ${opt} in
    h )
      echo &amp;quot;Usage:&amp;quot;
      echo &amp;quot;    pip -h                      Display this help message.&amp;quot;
      echo &amp;quot;    pip install &amp;lt;package&amp;gt;       Install &amp;lt;package&amp;gt;.&amp;quot;
      exit 0
      ;;
   \? )
     echo &amp;quot;Invalid Option: -$OPTARG&amp;quot; 1&amp;gt;&amp;amp;2
     exit 1
     ;;
  esac
done
shift $((OPTIND -1))

subcommand=$1; shift  # Remove &#39;pip&#39; from the argument list
case &amp;quot;$subcommand&amp;quot; in
  # Parse options to the install sub command
  install)
    package=$1; shift  # Remove &#39;install&#39; from the argument list

    # Process package options
    while getopts &amp;quot;:t:&amp;quot; opt; do
      case ${opt} in
        t )
          target=$OPTARG
          ;;
        \? )
          echo &amp;quot;Invalid Option: -$OPTARG&amp;quot; 1&amp;gt;&amp;amp;2
          exit 1
          ;;
        : )
          echo &amp;quot;Invalid Option: -$OPTARG requires an argument&amp;quot; 1&amp;gt;&amp;amp;2
          exit 1
          ;;
      esac
    done
    shift $((OPTIND -1))
    ;;
esac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After processing the above sequence of commands, the variable &lt;code&gt;package&lt;/code&gt; will
hold the package to install and the variable &lt;code&gt;target&lt;/code&gt; will hold the target to
install the package to. You can use this as a template for processing any set of
arguments and options to your scripts.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Bash String Operators</title>
      <link>http://sookocheff.com/post/bash/bash-string-operators/</link>
      <pubDate>Thu, 11 Dec 2014 19:54:12 UTC</pubDate>
      <author>kevin.sookocheff@gmail.com (Kevin Sookocheff)</author>
      <guid>http://sookocheff.com/post/bash/bash-string-operators/</guid>
      <description>

&lt;p&gt;A common task in &lt;em&gt;bash&lt;/em&gt; programming is to manipulate portions of a string and
return the result. &lt;em&gt;bash&lt;/em&gt; provides rich support for these manipulations via
string operators. The syntax is not always intuitive so I wanted to use this
blog post to serve as a permanent reminder of the operators.&lt;/p&gt;

&lt;p&gt;The string operators are signified with the &lt;code&gt;${}&lt;/code&gt; notation. The operations can be
grouped in to a few classes. Each heading in this article describes a class of
operation.&lt;/p&gt;

&lt;h2 id=&#34;substring-extraction:7e583942bdfc3c78b6cbe4c2e5cf901b&#34;&gt;Substring Extraction&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;extract-from-a-position:7e583942bdfc3c78b6cbe4c2e5cf901b&#34;&gt;Extract from a position&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;${string:position}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Extraction returns a substring of &lt;code&gt;string&lt;/code&gt; starting at &lt;code&gt;position&lt;/code&gt; and ending at the end of &lt;code&gt;string&lt;/code&gt;. &lt;code&gt;string&lt;/code&gt; is treated as an array of characters starting at 0.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; string=&amp;quot;hello world&amp;quot;
&amp;gt; echo ${string:1}
ello world
&amp;gt; echo ${string:6}
world
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;extract-from-a-position-with-a-length:7e583942bdfc3c78b6cbe4c2e5cf901b&#34;&gt;Extract from a position with a length&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;${string:position:length}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding a length returns a substring only as long as the &lt;code&gt;length&lt;/code&gt; parameter.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; string=&amp;quot;hello world&amp;quot;
&amp;gt; echo ${string:1:2}
el
&amp;gt; echo ${string:6:3}
wor
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;substring-removal:7e583942bdfc3c78b6cbe4c2e5cf901b&#34;&gt;Substring Removal&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;remove-shortest-starting-match:7e583942bdfc3c78b6cbe4c2e5cf901b&#34;&gt;Remove shortest starting match&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;${variable#pattern}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;variable&lt;/code&gt; &lt;em&gt;starts&lt;/em&gt; with &lt;code&gt;pattern&lt;/code&gt;, delete the &lt;em&gt;shortest&lt;/em&gt; part that matches the pattern.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; string=&amp;quot;hello world, hello jim&amp;quot;
&amp;gt; echo ${string#*hello}
world, hello jim
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;remove-longest-starting-match:7e583942bdfc3c78b6cbe4c2e5cf901b&#34;&gt;Remove longest starting match&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;${variable##pattern}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;variable&lt;/code&gt; &lt;em&gt;starts&lt;/em&gt; with &lt;code&gt;pattern&lt;/code&gt;, delete the &lt;em&gt;longest&lt;/em&gt; match from &lt;code&gt;variable&lt;/code&gt; and return the rest.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; string=&amp;quot;hello world, hello jim&amp;quot;
&amp;gt; echo ${string##*hello}
jim
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;remove-shortest-ending-match:7e583942bdfc3c78b6cbe4c2e5cf901b&#34;&gt;Remove shortest ending match&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;${variable%pattern}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;variable&lt;/code&gt; ends with &lt;code&gt;pattern&lt;/code&gt;, delete the shortest match from the end of &lt;code&gt;variable&lt;/code&gt; and return the rest.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; string=&amp;quot;hello world, hello jim&amp;quot;
&amp;gt; echo ${string%hello*}
hello world,
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;remove-longest-ending-match:7e583942bdfc3c78b6cbe4c2e5cf901b&#34;&gt;Remove longest ending match&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;${variable%%pattern}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;variable&lt;/code&gt; ends with &lt;code&gt;pattern&lt;/code&gt;, delete the longest match from the end of &lt;code&gt;variable&lt;/code&gt; and return the rest.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; string=&amp;quot;hello world, hello jim&amp;quot;
&amp;gt; echo ${string%%hello*}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;substring-replacement:7e583942bdfc3c78b6cbe4c2e5cf901b&#34;&gt;Substring Replacement&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;replace-first-occurrence-of-word:7e583942bdfc3c78b6cbe4c2e5cf901b&#34;&gt;Replace first occurrence of word&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;${variable/pattern/string}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find the first occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;variable&lt;/code&gt; and replace it with &lt;code&gt;string&lt;/code&gt;. If &lt;code&gt;string&lt;/code&gt; is null, &lt;code&gt;pattern&lt;/code&gt; is deleted from &lt;code&gt;variable&lt;/code&gt;. If &lt;code&gt;pattern&lt;/code&gt; starts with &lt;code&gt;#&lt;/code&gt;, the match must occur at the beginning of &lt;code&gt;variable&lt;/code&gt;. If &lt;code&gt;pattern&lt;/code&gt; starts with &lt;code&gt;%&lt;/code&gt;, the match must occur at the end of the &lt;code&gt;variable&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; string=&amp;quot;hello world, hello jim&amp;quot;
&amp;gt; echo ${string/hello/goodbye}
goodbye world, hello jim
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;replace-all-occurrences-of-word:7e583942bdfc3c78b6cbe4c2e5cf901b&#34;&gt;Replace all occurrences of word&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;${variable//pattern/string}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Same as above but finds &lt;strong&gt;all&lt;/strong&gt; occurrences of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;variable&lt;/code&gt; and replace them with &lt;code&gt;string&lt;/code&gt;. If &lt;code&gt;string&lt;/code&gt; is null, &lt;code&gt;pattern&lt;/code&gt; is deleted from &lt;code&gt;variable&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; string=&amp;quot;hello world, hello jim&amp;quot;
&amp;gt; echo ${string//hello/goodbye}
goodbye world, goodbye jim
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
